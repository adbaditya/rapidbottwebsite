<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Snow Glide ‚Äì Pixel Xmas Run (Downhill Edition)</title>
  <meta name="viewport"
        content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />

  <!-- Pixel Font -->
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap"
        rel="stylesheet" />

  <style>
    /* ------------------------------
       GLOBAL RESET + BASE STYLING
    ------------------------------- */
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #0d1b2a;
      font-family: 'Press Start 2P', monospace;
      touch-action: none;
    }

    #gameCanvas {
      position: absolute;
      top: 0;
      left: 0;
      background: #fdf5ef;
      width: 100vw;
      height: 100vh;
      touch-action: none;
    }

    /* Shake animation for strong collisions */
    @keyframes shake {
      0%   { transform: translate(0,0); }
      25%  { transform: translate(-4px, 3px); }
      50%  { transform: translate(3px, -3px); }
      75%  { transform: translate(-3px, 2px); }
      100% { transform: translate(0,0); }
    }
    #gameCanvas.shake {
      animation: shake 0.4s linear 1;
    }

    /* Player sprite */
    #playerSprite {
      position: absolute;
      width: 80px;
      height: 80px;
      image-rendering: pixelated;
      pointer-events: none;
      z-index: 3;
      display: none;
    }

    /* ----------------------------------------------
       UNIVERSAL MENU SCREENS (Start + Character)
    ----------------------------------------------- */
    #startScreen,
    #characterScreen {
      position: absolute;
      width: 100vw;
      height: 100vh;
      left: 0;
      top: 0;
      background: radial-gradient(circle at 50% 20%, #233647 0%, #0d1b2a 55%, #050b12 100%);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      z-index: 10;
      text-align: center;
      padding: 0 16px;
    }

    #characterScreen {
      z-index: 11;
      display: none;
    }

    /* Retro game title */
    .title {
      font-size: 24px;
      margin-bottom: 20px;
      text-shadow: 0 0 6px #6dc1f6;
    }

    .subtitle {
      font-size: 9px;
      margin-top: 4px;
      opacity: 0.8;
    }

    /* ------------------------------
       BUTTON STYLING
    ------------------------------- */
    .btn {
      background: linear-gradient(135deg,#c9e265,#6dc1f6);
      color: #0d1b2a;
      margin-top: 12px;
      padding: 12px 26px;
      cursor: pointer;
      font-size: 12px;
      border-radius: 999px;
      box-shadow: 0 0 15px rgba(0,0,0,0.5);
      text-align: center;
      min-width: 180px;
    }

    .btn.secondary {
      background: rgba(0,0,0,0.3);
      color: #ffffff;
      border: 2px solid #c9e265;
      box-shadow: none;
    }

    /* ‚ÄúBy Rapidbott‚Äù footer */
    .byText {
      position: absolute;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 8px;
      opacity: 0.75;
    }

    /* Menu snow overlay animation */
    #startScreen::after,
    #characterScreen::after {
      content: "";
      position: absolute;
      inset: 0;
      background-image: radial-gradient(#ffffff 1px, transparent 1px);
      background-size: 4px 4px;
      opacity: 0.12;
      pointer-events: none;
      animation: menuSnow 1.2s linear infinite;
    }

    @keyframes menuSnow {
      from { background-position: 0 0; }
      to   { background-position: 0 8px; }
    }

    /* Sound toggle on top-left */
    .soundToggle {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.4);
      border-radius: 999px;
      border: 1px solid #c9e265;
      padding: 4px 10px;
      font-size: 9px;
      cursor: pointer;
      z-index: 25;
    }

    /* -----------------------------------
       NEW: DIFFICULTY MODAL CSS (UI3)
    ------------------------------------ */
    .difficultyModalOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 50;
      padding: 0 16px;
    }

    .difficultyModalBox {
      background: radial-gradient(circle at 0% 0%, #1d2b3c 0%, #050b12 70%);
      border-radius: 18px;
      max-width: 360px;
      width: 100%;
      border: 1px solid #6dc1f6;
      box-shadow: 0 0 30px rgba(0,0,0,0.8);
      padding: 20px;
      color: #ffffff;
      position: relative;
      overflow: hidden;
      text-align: center;
    }

    .difficultyModalTitle {
      font-size: 14px;
      margin-bottom: 12px;
      text-shadow: 0 0 6px #6dc1f6;
    }

    .difficultyOption {
      background: rgba(0,0,0,0.4);
      border: 2px solid transparent;
      border-radius: 12px;
      padding: 12px;
      margin: 8px 0;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 11px;
    }

    /* GREEN GLOW for selected difficulty */
    .difficultyOption.selected {
      border: 2px solid #c9e265;
      box-shadow: 0 0 10px rgba(201, 226, 101, 0.7);
      background: rgba(255,255,255,0.05);
    }

    .difficultyOption:hover {
      background: rgba(255,255,255,0.08);
    }

    /* Close button */
    .difficultyClose {
      position: absolute;
      right: 12px;
      top: 10px;
      cursor: pointer;
      font-size: 14px;
      opacity: 0.8;
    }
    .difficultyClose:hover { opacity: 1; }

  </style>
</head>


<body>

<!-- GAME CANVAS -->
<canvas id="gameCanvas"></canvas>
<img id="playerSprite" src="" alt="player" />

<!-- ============================
     START SCREEN (with Difficulty)
     ============================ -->
<div id="startScreen">
  <div id="soundToggleMain" class="soundToggle" onclick="toggleSound()"></div>

  <div>
    <div class="title">‚ùÑ SNOW GLIDE ‚ùÑ<br/>PIXEL XMAS RUN</div>

    <div class="btn" onclick="playUiClick(); openCharacterSelect()">PLAY GAME</div>
    <div class="btn secondary" onclick="playUiClick(); openHowToPlay()">HOW TO PLAY</div>
    <div class="btn secondary" onclick="playUiClick(); openLeaderboard()">LEADERBOARD</div>

    <!-- NEW DIFFICULTY BUTTON -->
    <div class="btn secondary" onclick="playUiClick(); openDifficultyModal()">DIFFICULTY</div>

    <div class="subtitle" style="margin-top:16px;">
      Endless downhill skating through a winter wonderland.
    </div>
  </div>

  <div class="byText">By Rapidbott</div>
</div>

<!-- ================================
     CHARACTER SELECTION SCREEN
     ================================ -->
<div id="characterScreen">
  <div id="soundToggleChar" class="soundToggle" onclick="toggleSound()"></div>

  <div class="title">SELECT YOUR SKATER</div>

  <!-- Character Grid -->
  <div id="characterGrid"
       style="display:flex;flex-wrap:wrap;justify-content:center;gap:18px;margin-top:10px;">
    <!-- Characters injected by JS -->
  </div>

  <!-- NEW DIFFICULTY BUTTON INSIDE CHARACTER SCREEN -->
  <div class="btn secondary"
       style="margin-top:24px;"
       onclick="playUiClick(); openDifficultyModal()">
       DIFFICULTY
  </div>

  <!-- Confirm Character -->
  <div class="btn" style="margin-top:20px;" onclick="playUiClick(); startGameFromCharacter()">
    START GAME
  </div>

  <div class="byText">By Rapidbott</div>
</div>



<!-- ================================
     DIFFICULTY SELECT MODAL (D-UI3)
     ================================ -->
<div id="difficultyModal" class="difficultyModalOverlay">
  <div class="difficultyModalBox">

    <div class="difficultyClose" onclick="closeDifficultyModal()">‚úï</div>

    <div class="difficultyModalTitle">
      SELECT DIFFICULTY
    </div>

    <!-- AUTO MODE -->
    <div class="difficultyOption" id="difficulty_auto"
         onclick="selectDifficulty('auto')">
      ‚ùÑ AUTO (Adaptive)
      <div style="font-size:9px;margin-top:6px;opacity:0.8;">
        Difficulty adjusts dynamically based on your skill.
      </div>
    </div>

    <!-- EASY -->
    <div class="difficultyOption" id="difficulty_easy"
         onclick="selectDifficulty('easy')">
      üê• EASY
      <div style="font-size:9px;margin-top:6px;opacity:0.8;">
        Slow downhill speed. Great for beginners.
      </div>
    </div>

    <!-- MEDIUM -->
    <div class="difficultyOption" id="difficulty_medium"
         onclick="selectDifficulty('medium')">
      ‚õ∞Ô∏è MEDIUM
      <div style="font-size:9px;margin-top:6px;opacity:0.8;">
        The balanced Snow Glide experience.
      </div>
    </div>

    <!-- HARD -->
    <div class="difficultyOption" id="difficulty_hard"
         onclick="selectDifficulty('hard')">
      üî• HARD
      <div style="font-size:9px;margin-top:6px;opacity:0.8;">
        Fast, intense, challenging. Only for pros!
      </div>
    </div>

  </div>
</div>



<!-- ================================
     HOW TO PLAY MODAL
     ================================ -->
<div id="howToPlayModal"
     style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.7);
            z-index:50;align-items:center;justify-content:center;padding:16px;">

  <div style="background:#0d1b2a;border-radius:18px;max-width:360px;width:100%;
              padding:20px;color:white;border:1px solid #6dc1f6;
              box-shadow:0 0 30px rgba(0,0,0,0.8);text-align:center;">

    <div style="font-size:14px;margin-bottom:10px;text-shadow:0 0 6px #6dc1f6;">
      HOW TO PLAY
    </div>

    <div style="font-size:10px;line-height:1.5;">
      ‚Ä¢ Drag left or right to move your skater.<br><br>
      ‚Ä¢ Avoid trees, ice golems & rolling snowballs.<br><br>
      ‚Ä¢ Collect green gifts for bonus score.<br><br>
      ‚Ä¢ The longer you survive, the faster the downhill becomes.<br><br>
      Good luck!
    </div>

    <div class="btn" style="margin-top:16px;" onclick="closeHowToPlay()">OK</div>
  </div>
</div>



<!-- ================================
     LEADERBOARD MODAL
     ================================ -->
<div id="leaderboardModal"
     style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.7);
            z-index:55;align-items:center;justify-content:center;padding:16px;">

  <div style="background:#0d1b2a;border-radius:18px;max-width:380px;width:100%;
              padding:20px;color:white;border:1px solid #6dc1f6;
              box-shadow:0 0 30px rgba(0,0,0,0.8);max-height:80vh;overflow-y:auto;">

    <div style="font-size:14px;margin-bottom:10px;text-shadow:0 0 6px #6dc1f6;">
      LEADERBOARD
    </div>

    <div id="leaderboardList" style="font-size:10px;line-height:1.8;">
      <!-- Entries will be injected by JS -->
    </div>

    <div class="btn" style="margin-top:16px;" onclick="closeLeaderboard()">OK</div>
  </div>
</div>

<style>
/* ======================================
   CHARACTER GRID STYLING
====================================== */
.characterCard {
  width: 90px;
  height: 110px;
  background: rgba(255,255,255,0.05);
  border: 2px solid rgba(255,255,255,0.15);
  border-radius: 12px;
  padding: 8px;
  display: flex;
  flex-direction: column;
  align-items: center;
  cursor: pointer;
  transition: all 0.2s ease-in-out;
}

.characterCard:hover {
  background: rgba(255,255,255,0.08);
}

.characterCard.selected {
  border: 2px solid #c9e265;
  box-shadow: 0 0 10px rgba(201,226,101,0.7);
  background: rgba(255,255,255,0.12);
}

.characterCard img {
  width: 60px;
  height: 60px;
  image-rendering: pixelated;
}

.characterName {
  font-size: 9px;
  margin-top: 6px;
  color: #ffffff;
  opacity: 0.9;
}


/* ======================================
   SCORE + LIVES UI DURING GAMEPLAY
====================================== */
#scoreUI {
  position: absolute;
  top: 12px;
  right: 12px;
  font-size: 14px;
  color: #ffffff;
  text-shadow: 0 0 5px #000;
  z-index: 20;
  display: none;
}

#livesUI {
  position: absolute;
  top: 12px;
  left: 12px;
  font-size: 14px;
  color: #ffffff;
  text-shadow: 0 0 5px #000;
  z-index: 20;
  display: none;
}


/* ======================================
   PAUSE + RESUME OVERLAY
====================================== */
#pauseOverlay {
  position: absolute;
  inset: 0;
  background: rgba(0,0,0,0.55);
  z-index: 30;
  display: none;
  align-items: center;
  justify-content: center;
}

.pauseBox {
  background: #0d1b2a;
  padding: 20px;
  border-radius: 16px;
  text-align: center;
  border: 1px solid #6dc1f6;
  color: white;
  width: 220px;
  box-shadow: 0 0 30px rgba(0,0,0,0.8);
}

.pauseBox .title {
  font-size: 14px;
  margin-bottom: 10px;
}

.pauseBtn {
  margin-top: 12px;
  background: linear-gradient(135deg,#c9e265,#6dc1f6);
  padding: 10px;
  border-radius: 999px;
  cursor: pointer;
}


/* ======================================
   GAME OVER SCORE CARD
====================================== */
#gameOverCard {
  position: absolute;
  inset: 0;
  background: rgba(0,0,0,0.65);
  z-index: 40;
  display: none;
  align-items: center;
  justify-content: center;
}

.gameOverBox {
  background: #0d1b2a;
  padding: 24px;
  width: 260px;
  border-radius: 16px;
  text-align: center;
  border: 1px solid #6dc1f6;
  color: white;
  box-shadow: 0 0 25px rgba(0,0,0,0.7);
}

.gameOverBox .title {
  font-size: 14px;
}

.gameOverScore {
  font-size: 12px;
  margin-top: 12px;
  margin-bottom: 18px;
  text-shadow: 0 0 6px #c9e265;
}

.gameOverBtn {
  background: linear-gradient(135deg,#c9e265,#6dc1f6);
  padding: 12px;
  border-radius: 999px;
  margin-top: 12px;
  cursor: pointer;
}


/* ======================================
   NAME ENTRY MODAL (FOR LEADERBOARD)
====================================== */
#nameEntryModal {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.7);
  z-index: 70;
  display: none;
  align-items: center;
  justify-content: center;
  padding: 16px;
}

.nameEntryBox {
  background: #0d1b2a;
  padding: 20px;
  border-radius: 18px;
  max-width: 320px;
  width: 100%;
  color: white;
  border: 1px solid #6dc1f6;
  box-shadow: 0 0 30px rgba(0,0,0,0.8);
  text-align: center;
}

.nameEntryBox input {
  width: 90%;
  padding: 10px;
  margin-top: 12px;
  border-radius: 8px;
  outline: none;
  border: none;
  background: rgba(255,255,255,0.1);
  color: white;
  font-size: 12px;
}

.nameEntryBox .btn {
  margin-top: 16px;
}


/* ======================================
   NOTIFICATION / TOAST POPUP
====================================== */
.toast {
  position: absolute;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.7);
  padding: 10px 16px;
  border-radius: 999px;
  color: white;
  font-size: 10px;
  opacity: 0;
  transition: opacity 0.3s ease;
  z-index: 90;
}

.toast.show {
  opacity: 1;
}


/* ======================================
   MISC UI LABELS
====================================== */

#speedIndicator {
  position: absolute;
  bottom: 20px;
  right: 14px;
  font-size: 10px;
  color: #ffffff;
  opacity: 0.8;
  z-index: 25;
}

#distanceIndicator {
  position: absolute;
  bottom: 20px;
  left: 14px;
  font-size: 10px;
  color: #ffffff;
  opacity: 0.8;
  z-index: 25;
}


/* ==========================================
   LEADERBOARD MODAL
========================================== */

#leaderboardModal {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.75);
  z-index: 70;
  display: none;
  align-items: center;
  justify-content: center;
  padding: 16px;
}

.leaderboardBox {
  background: #0d1b2a;
  width: 90%;
  max-width: 340px;
  max-height: 80%;
  overflow-y: auto;
  padding: 20px;
  border-radius: 16px;
  border: 1px solid #6dc1f6;
  box-shadow: 0 0 20px rgba(0,0,0,0.65);
  color: white;
}

.modalTitle {
  font-size: 16px;
  font-weight: bold;
  text-align: center;
  margin-bottom: 12px;
  color: #c9e265;
}

/* Leaderboard rows */
.leaderboardList {
  width: 100%;
}

.lbRow {
  display: flex;
  justify-content: space-between;
  padding: 8px 10px;
  margin-bottom: 6px;
  background: rgba(255,255,255,0.06);
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.08);
  font-size: 12px;
}

.lbRow:hover {
  background: rgba(255,255,255,0.12);
}

.lbRank {
  font-weight: bold;
  color: #6dc1f6;
}

.lbName {
  flex: 1;
  text-align: center;
  color: #ffffff;
}

.lbScore {
  color: #c9e265;
}

/* Back button styling */
.backBtn {
  margin-top: 16px;
  text-align: center;
  padding: 10px;
  background: linear-gradient(135deg, #c9e265, #6dc1f6);
  color: #0d1b2a;
  border-radius: 999px;
  cursor: pointer;
}



</style>


<!-- ==========================================
     PAUSE OVERLAY
========================================== -->
<div id="pauseOverlay">
  <div class="pauseBox">
    <div class="title">GAME PAUSED</div>
    <div class="pauseBtn" onclick="resumeGame()">RESUME</div>
    <div class="pauseBtn" onclick="quitToMenu()">QUIT</div>
  </div>
</div>


<!-- ==========================================
     GAME OVER CARD
========================================== -->
<div id="gameOverCard">
  <div class="gameOverBox">
    <div class="title">GAME OVER</div>

    <div id="finalScoreText" class="gameOverScore">
      Your Score: 0
    </div>

    <div class="gameOverBtn" onclick="retryGame()">RETRY</div>
    <div class="gameOverBtn" onclick="openNameEntry()">SAVE SCORE</div>
    <div class="gameOverBtn" onclick="quitToMenu()">MAIN MENU</div>
  </div>
</div>


<!-- ==========================================
     NAME ENTRY (LEADERBOARD SUBMISSION)
========================================== -->
<div id="nameEntryModal">
  <div class="nameEntryBox">
    <div class="title">ENTER YOUR NAME</div>

    <input id="playerNameInput" 
           type="text"
           placeholder="Your Name"
           maxlength="12" />

    <div class="btn" onclick="submitScore()">SUBMIT</div>
  </div>
</div>


<!-- ==========================================
     TOAST NOTIFICATION
========================================== -->
<div id="toast" class="toast"></div>


<!-- ==========================================
     SCORE UI OVERLAYS
========================================== -->
<div id="scoreUI">0</div>
<div id="livesUI">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
<div id="speedIndicator"></div>
<div id="distanceIndicator"></div>


<!-- ==========================================
     LEADERBOARD MODAL
========================================== -->
<div id="leaderboardModal" class="modal">
  <div class="modalBox leaderboardBox">

    <div class="modalTitle">Leaderboard</div>

    <div id="leaderboardList" class="leaderboardList"></div>

    <div class="backBtn">Back</div>
  </div>
</div>



<!-- ==========================================
     END OF HTML ‚Äî JS WILL BEGIN BELOW
========================================== -->

<!-- JS begins in PART 2 -->
<script>
/* JS WILL BE INSERTED IN PART 2, 3, 4 */

/* ==========================================
   PART 2A ‚Äî CORE ENGINE SETUP
========================================== */

// Canvas
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
resizeCanvas();

window.addEventListener("resize", resizeCanvas);
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}

/* ==========================================
   GLOBAL GAME STATE
========================================== */
let gameRunning = false;
let gameOver = false;
let paused = false;

let score = 0;          // S3 ‚Äî score tied to world movement
let distance = 0;       // downhill meters
let lives = 3;

let worldSpeed = 3;     // base speed
let baseSpeed = 2.2;    // Option D1 ‚Äî Easy start

/* ==========================================
   DIFFICULTY SYSTEM (M2 + M3)
========================================== */

// User-selected difficulty: "auto", "easy", "medium", "hard"
let difficultyMode = "auto";

// internal scaler for auto mode
let autoDifficultyLevel = 0;   
// grows dynamically based on how well player survives

// difficulty presets
const difficultySettings = {
  easy:   { speed: 2.2 },
  medium: { speed: 3.3 },
  hard:   { speed: 4.6 },
};

// called when user selects difficulty button
function setDifficulty(mode) {
  difficultyMode = mode;
  closeDifficultyModal();

  // UI feedback
  showToast("Difficulty set to: " + mode.toUpperCase());
}

/* ==========================================
   AUTO DIFFICULTY (M3)
   Dynamic hidden system
========================================== */

function updateAutoDifficulty() {
  if (difficultyMode !== "auto") return;

  // increase slowly based on survival time
  autoDifficultyLevel += 0.00025;

  // cap max intensity (to avoid insane difficulty)
  if (autoDifficultyLevel > 2.5) {
    autoDifficultyLevel = 2.5;
  }
}

/* ==========================================
   COMPUTE WORLD SPEED
   Option D1 ‚Üí Easy Start
   ‚Üí transitions to D2 ‚Üí D3 naturally
========================================== */

function computeWorldSpeed() {
  if (difficultyMode === "easy")   return difficultySettings.easy.speed;
  if (difficultyMode === "medium") return difficultySettings.medium.speed;
  if (difficultyMode === "hard")   return difficultySettings.hard.speed;

  // AUTO MODE ‚Üí base + dynamic scaling
  return baseSpeed + autoDifficultyLevel;
}

/* ==========================================
   PLAYER OBJECT
========================================== */
const player = {
  x: canvas.width / 2,
  y: canvas.height * 0.15,   // Option A1 ‚Äî Start at top center
  width: 80,
  height: 80,
  speedX: 0,
  speedY: 0,
};

// ensure player always starts centered at top
function resetPlayerPosition() {
  player.x = canvas.width / 2 - player.width / 2;
  player.y = canvas.height * 0.15;
}

/* ==========================================
   INPUT SYSTEM (keyboard + touch)
========================================== */
const keys = { left:false, right:false, up:false, down:false };

window.addEventListener("keydown", (e) => {
  if (e.key === "ArrowLeft") keys.left = true;
  if (e.key === "ArrowRight") keys.right = true;
  if (e.key === "ArrowUp") keys.up = true;
  if (e.key === "ArrowDown") keys.down = true;
});

window.addEventListener("keyup", (e) => {
  if (e.key === "ArrowLeft") keys.left = false;
  if (e.key === "ArrowRight") keys.right = false;
  if (e.key === "ArrowUp") keys.up = false;
  if (e.key === "ArrowDown") keys.down = false;
});

// Touch control placeholders ‚Äî real logic in Part 3
let touchActive = false;
window.addEventListener("touchstart", () => touchActive = true);
window.addEventListener("touchend",   () => touchActive = false);
window.addEventListener("touchmove", (e) => {
  // actual movement handled later
  e.preventDefault();
}, { passive:false });

/* ==========================================
   TOAST SYSTEM (General UI feedback)
========================================== */
function showToast(msg) {
  const toast = document.getElementById("toast");
  toast.innerText = msg;
  toast.style.opacity = "1";

  setTimeout(() => {
    toast.style.opacity = "0";
  }, 1800);
}

/* ==========================================
   PART 2B ‚Äî MOVEMENT + WORLD DESCENT + SCORE
========================================== */

/* ==========================================
   PLAYER MOVEMENT (keyboard + touch drag)
========================================== */

function updatePlayer(dt) {
  const moveSpeed = 420 * dt; // smooth & frame-independent

  if (keys.left)  player.x -= moveSpeed;
  if (keys.right) player.x += moveSpeed;
  if (keys.up)    player.y -= moveSpeed * 0.7;  // slight control upward
  if (keys.down)  player.y += moveSpeed;

  // Touch drag movement
  if (touchActive && lastTouchPos) {
    const dx = lastTouchPos.x - player.x - player.width / 2;
    const dy = lastTouchPos.y - player.y - player.height / 2;
    player.x += dx * 0.25;
    player.y += dy * 0.25;
  }

  // Clamp player inside canvas
  if (player.x < 0) player.x = 0;
  if (player.x + player.width > canvas.width)
    player.x = canvas.width - player.width;

  if (player.y < 0) player.y = 0;
  if (player.y + player.height > canvas.height)
    player.y = canvas.height - player.height;
}

/* Record touch movement */
let lastTouchPos = null;

window.addEventListener("touchmove", (e) => {
  const t = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  lastTouchPos = {
    x: t.clientX - rect.left,
    y: t.clientY - rect.top
  };
});


/* ==========================================
   WORLD DESCENDING MOVEMENT
========================================== */

let worldOffset = 0; // moves downward visually

function updateWorld(dt) {
  worldSpeed = computeWorldSpeed();
  worldOffset += worldSpeed;

  // S3 ‚Äî score based on world movement
  distance += worldSpeed * 0.02;
  score = Math.floor(distance);

  updateHUD();
}


/* ==========================================
   HUD UPDATE
========================================== */

function updateHUD() {
  document.getElementById("scoreUI").innerHTML = score + " m";
  document.getElementById("distanceIndicator").innerHTML = 
      "Speed: " + worldSpeed.toFixed(1);

  document.getElementById("livesUI").innerHTML = "‚ù§Ô∏è".repeat(lives);
}


/* ==========================================
   TRAIL SYSTEM (KEEP EXACT SAME DIRECTION)
========================================== */

let trail = [];

function updateTrail(dt) {
  // Add a new trail point if player is moving
  trail.push({
    x: player.x + player.width / 2,
    y: player.y + player.height
  });

  // Limit trail length
  if (trail.length > 160) trail.shift();

  // Move trail downward slowly (to maintain downhill illusion)
  const trailSpeed = worldSpeed * 0.45;
  for (let p of trail) {
    p.y += trailSpeed;
  }
}

function drawTrail() {
  if (trail.length < 2) return;

  ctx.lineCap = "round";
  ctx.lineWidth = 7;
  ctx.strokeStyle = "rgba(109,193,246,0.9)";

  ctx.beginPath();
  for (let i = 0; i < trail.length; i++) {
    const p = trail[i];
    if (i === 0) ctx.moveTo(p.x, p.y);
    else ctx.lineTo(p.x, p.y);
  }
  ctx.stroke();
}


/* ==========================================
   BACKGROUND (simple placeholder)
========================================== */

function drawBackground() {
  const h = canvas.height;
  const g = ctx.createLinearGradient(0, 0, 0, h);

  g.addColorStop(0, "#4fa3e3");
  g.addColorStop(1, "#d8f2ff");

  ctx.fillStyle = g;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
}


/* ==========================================
   HITBOX (for collisions later in Part 3)
========================================== */

function getPlayerHitbox() {
  return {
    x: player.x + player.width * 0.2,
    y: player.y + player.height * 0.25,
    w: player.width * 0.6,
    h: player.height * 0.6
  };
}

/* ==========================================
   PART 2C ‚Äî MAIN GAME LOOP + RENDER ORDER
========================================== */

let lastTimestamp = 0;

function gameLoop(timestamp) {
  if (!gameRunning) return;

  const dt = (timestamp - lastTimestamp) / 1000;
  lastTimestamp = timestamp;

  if (!paused) {
    // AUTO difficulty adjusts continuously
    updateAutoDifficulty();

    // Update world descent speed + score
    updateWorld(dt);

    // Player movement
    updatePlayer(dt);

    // Trail update
    updateTrail(dt);

    // Spawn / update obstacles (Part 3)
    updateObstacles(dt);
    updateGifts(dt);
    updateBigSnowballs(dt);
    updateGolems(dt);
  }

  // DRAW EVERYTHING
  renderFrame();

  requestAnimationFrame(gameLoop);
}


/* ==========================================
   RENDER PIPELINE (drawing order)
========================================== */

function renderFrame() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // 1. Background first
  drawBackground();

  // 2. Trail (behind player)
  drawTrail();

  // 3. Obstacles + Gifts
  drawObstacles();
  drawGifts();
  drawBigSnowballs();
  drawGolems();

  // 4. Player
  drawPlayer();

  // 5. Optional overlays (tutorials etc)
}


/* ==========================================
   DRAW PLAYER
========================================== */

function drawPlayer() {
  ctx.fillStyle = "#ff3366";
  ctx.fillRect(player.x, player.y, player.width, player.height);

  // Later: draw sprite image
}


/* ==========================================
   PAUSE LOGIC
========================================== */

function togglePause() {
  if (!gameRunning) return;

  paused = !paused;

  document.getElementById("pauseOverlay").style.display =
      paused ? "flex" : "none";
}

function resumeGame() {
  paused = false;
  document.getElementById("pauseOverlay").style.display = "none";
}

window.addEventListener("keydown", (e) => {
  if (e.key === "Escape") togglePause();
});


/* ==========================================
   START GAME
========================================== */

function startGame() {
  score = 0;
  distance = 0;
  lives = 3;

  worldOffset = 0;
  autoDifficultyLevel = 0;

  resetPlayerPosition();

  // Clear existing objects
  obstacles = [];
  gifts = [];
  bigSnowballs = [];
  golems = [];
  golemBullets = [];
  trail = [];

  document.getElementById("startScreen").style.display = "none";
  document.getElementById("characterScreen").style.display = "none";
  document.getElementById("gameOverCard").style.display = "none";

  gameRunning = true;
  paused = false;
  lastTimestamp = performance.now();

  requestAnimationFrame(gameLoop);
}


/* ==========================================
   GAME OVER
========================================== */

function triggerGameOver() {
  gameRunning = false;
  paused = false;

  document.getElementById("finalScoreText").innerHTML =
    "Your Score: " + score + " m";

  document.getElementById("gameOverCard").style.display = "flex";
}


/* ==========================================
   RETRY
========================================== */

function retryGame() {
  triggerGameOver(false);
  startGame();
}


/* ==========================================
   QUIT TO MENU
========================================== */

function quitToMenu() {
  gameRunning = false;
  paused = false;

  document.getElementById("pauseOverlay").style.display = "none";
  document.getElementById("gameOverCard").style.display = "none";

  document.getElementById("startScreen").style.display = "flex";
}

/* ==========================================
   PART 3A ‚Äî OBSTACLES + GIFTS + COLLISIONS
========================================== */

/* Gameplay arrays */
let obstacles = [];   // trees
let gifts = [];        // green (points) / red (life)

/* Spawn timers */
let obstacleTimer = 0;
let giftTimer = 0;

/* ==========================================
   SPAWN OBSTACLES (Trees)
========================================== */

function spawnObstacle() {
  const w = 48;
  const h = 80;

  const margin = 60;
  const x = margin + Math.random() * (canvas.width - margin * 2 - w);

  obstacles.push({
    x,
    y: -100,
    w,
    h,
  });
}

function updateObstacles(dt) {
  const fallSpeed = worldSpeed * 1.0;

  obstacleTimer += dt * worldSpeed;

  // spawn every ~30 "meters"
  if (obstacleTimer > 30) {
    spawnObstacle();
    obstacleTimer = 0;
  }

  const hitbox = getPlayerHitbox();

  for (let i = obstacles.length - 1; i >= 0; i--) {
    const o = obstacles[i];
    o.y += fallSpeed;

    // collision
    if (
      rectsOverlap(hitbox.x, hitbox.y, hitbox.w, hitbox.h, o.x, o.y, o.w, o.h)
    ) {
      obstacles.splice(i, 1);
      lifeLost();
      continue;
    }

    // remove off-screen
    if (o.y > canvas.height + 80) {
      obstacles.splice(i, 1);
    }
  }
}

/* Render */
function drawObstacles() {
  obstacles.forEach((o) => {
    // shadow
    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.beginPath();
    ctx.ellipse(o.x + o.w / 2, o.y + o.h, o.w * 0.5, 10, 0, 0, Math.PI * 2);
    ctx.fill();

    // trunk
    ctx.fillStyle = "#7d4b27";
    ctx.fillRect(o.x + o.w * 0.4, o.y + o.h * 0.65, o.w * 0.2, o.h * 0.35);

    // tree shape
    ctx.fillStyle = "#276b47";
    ctx.beginPath();
    ctx.moveTo(o.x + o.w / 2, o.y);
    ctx.lineTo(o.x, o.y + o.h * 0.8);
    ctx.lineTo(o.x + o.w, o.y + o.h * 0.8);
    ctx.closePath();
    ctx.fill();
  });
}

/* ==========================================
   GIFTS (Green = points, Red = life)
========================================== */

function spawnGift() {
  const w = 40;
  const h = 40;

  const margin = 40;
  const x = margin + Math.random() * (canvas.width - margin * 2 - w);

  const type = Math.random() < 0.75 ? "points" : "life";

  gifts.push({
    x,
    y: -100,
    w,
    h,
    type,
  });
}

function updateGifts(dt) {
  const fallSpeed = worldSpeed * 1.0;

  giftTimer += dt * worldSpeed;

  // spawn every ~60 meters
  if (giftTimer > 60) {
    spawnGift();
    giftTimer = 0;
  }

  const hitbox = getPlayerHitbox();

  for (let i = gifts.length - 1; i >= 0; i--) {
    const g = gifts[i];
    g.y += fallSpeed;

    // collision
    if (
      rectsOverlap(hitbox.x, hitbox.y, hitbox.w, hitbox.h, g.x, g.y, g.w, g.h)
    ) {
      if (g.type === "points") {
        score += 150;
      } else if (g.type === "life") {
        if (lives < 3) lives++;
      }
      gifts.splice(i, 1);
      continue;
    }

    // off screen
    if (g.y > canvas.height + 80) {
      gifts.splice(i, 1);
    }
  }
}

/* Render */
function drawGifts() {
  gifts.forEach((g) => {
    ctx.fillStyle = g.type === "points" ? "#c9e265" : "#ff3b6a";
    ctx.fillRect(g.x, g.y, g.w, g.h);

    // ribbon
    ctx.fillStyle = "#ffffff";
    ctx.fillRect(g.x + g.w / 2 - 3, g.y, 6, g.h);
    ctx.fillRect(g.x, g.y + g.h / 2 - 3, g.w, 6);
  });
}

/* ==========================================
   COLLISION UTILITY
========================================== */

function rectsOverlap(ax, ay, aw, ah, bx, by, bw, bh) {
  return (
    ax < bx + bw &&
    ax + aw > bx &&
    ay < by + bh &&
    ay + ah > by
  );
}

/* ==========================================
   LIFE LOST HANDLER
========================================== */

function lifeLost() {
  lives--;
  if (lives <= 0) {
    triggerGameOver();
  }
}

/* ==========================================
   PART 3B ‚Äî BIG SNOWBALLS + GOLEMS + PROJECTILES
========================================== */

/* Arrays */
let bigSnowballs = [];
let golems = [];
let golemBullets = [];

/* Spawn timers */
let bigSnowballTimer = 0;
let golemTimer = 0;


/* ==========================================
   BIG SNOWBALLS (falling hazards)
========================================== */

function spawnBigSnowball() {
  const r = 48;
  const x = r + Math.random() * (canvas.width - r * 2);
  const y = -120;

  const vx = (Math.random() - 0.5) * 1.2; // slight side motion

  bigSnowballs.push({
    x,
    y,
    r,
    vx,
  });
}

function updateBigSnowballs(dt) {
  const fall = worldSpeed * 1.1;

  bigSnowballTimer += dt * worldSpeed;

  // spawn every ~120 meters
  if (bigSnowballTimer > 120) {
    spawnBigSnowball();
    bigSnowballTimer = 0;
  }

  const hitbox = getPlayerHitbox();

  for (let i = bigSnowballs.length - 1; i >= 0; i--) {
    const b = bigSnowballs[i];

    b.y += fall;
    b.x += b.vx;

    // collision (circle vs rectangle)
    const closestX = Math.max(hitbox.x, Math.min(b.x, hitbox.x + hitbox.w));
    const closestY = Math.max(hitbox.y, Math.min(b.y, hitbox.y + hitbox.h));

    const dx = b.x - closestX;
    const dy = b.y - closestY;

    if (dx * dx + dy * dy < b.r * b.r) {
      bigSnowballs.splice(i, 1);
      lifeLost();
      continue;
    }

    // off screen
    if (b.y > canvas.height + b.r) {
      bigSnowballs.splice(i, 1);
    }
  }
}

function drawBigSnowballs() {
  bigSnowballs.forEach((b) => {
    // shadow
    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.beginPath();
    ctx.ellipse(b.x, b.y + b.r * 0.8, b.r * 0.8, 12, 0, 0, Math.PI * 2);
    ctx.fill();

    // body
    const grad = ctx.createRadialGradient(
      b.x - b.r * 0.3,
      b.y - b.r * 0.3,
      b.r * 0.1,
      b.x,
      b.y,
      b.r
    );
    grad.addColorStop(0, "#ffffff");
    grad.addColorStop(0.5, "#d6f0ff");
    grad.addColorStop(1, "#7fa8d9");

    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
    ctx.fill();
  });
}


/* ==========================================
   GOLEMS (walking enemies)
========================================== */

function spawnGolem() {
  const w = 70;
  const h = 90;

  const x = 40 + Math.random() * (canvas.width - 80);
  const y = -160;

  golems.push({
    x,
    y,
    w,
    h,
    shootCooldown: 1 + Math.random() * 1.5, // seconds
  });
}

function updateGolems(dt) {
  const fall = worldSpeed * 0.9;

  golemTimer += dt * worldSpeed;

  // spawn every ~200 meters
  if (golemTimer > 200) {
    spawnGolem();
    golemTimer = 0;
  }

  const hitbox = getPlayerHitbox();

  for (let i = golems.length - 1; i >= 0; i--) {
    const g = golems[i];

    g.y += fall;

    // collision box
    if (
      rectsOverlap(
        hitbox.x, hitbox.y, hitbox.w, hitbox.h,
        g.x, g.y, g.w, g.h
      )
    ) {
      golems.splice(i, 1);
      lifeLost();
      continue;
    }

    // shooting logic
    g.shootCooldown -= dt;
    if (g.shootCooldown <= 0) {
      fireGolemSnowball(g);
      g.shootCooldown = 1.2 + Math.random() * 1.2;
    }

    // off screen
    if (g.y > canvas.height + 120) {
      golems.splice(i, 1);
    }
  }
}

function drawGolems() {
  golems.forEach((g) => {
    // shadow
    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.beginPath();
    ctx.ellipse(g.x + g.w / 2, g.y + g.h, g.w * 0.6, 12, 0, 0, Math.PI * 2);
    ctx.fill();

    // body
    const grad = ctx.createLinearGradient(g.x, g.y, g.x, g.y + g.h);
    grad.addColorStop(0, "#e8f8ff");
    grad.addColorStop(1, "#7fc4ff");

    ctx.fillStyle = grad;
    ctx.fillRect(g.x, g.y, g.w, g.h);

    // head
    ctx.fillStyle = "#e8f8ff";
    ctx.fillRect(g.x + 10, g.y - 24, g.w - 20, 24);

    // eyes
    ctx.fillStyle = "#173d5c";
    ctx.fillRect(g.x + 18, g.y - 14, 6, 4);
    ctx.fillRect(g.x + g.w - 24, g.y - 14, 6, 4);

    ctx.fillStyle = "#6dc1f6";
    ctx.fillRect(g.x + 19, g.y - 13, 4, 2);
    ctx.fillRect(g.x + g.w - 23, g.y - 13, 4, 2);
  });
}


/* ==========================================
   GOLEM PROJECTILES (snowballs)
========================================== */

function fireGolemSnowball(g) {
  const px = player.x + player.width / 2;
  const py = player.y + player.height / 2;

  const ox = g.x + g.w / 2;
  const oy = g.y;

  let dx = px - ox;
  let dy = py - oy;
  const mag = Math.sqrt(dx * dx + dy * dy) || 1;

  dx /= mag;
  dy /= mag;

  const speed = 300 + worldSpeed * 40;

  golemBullets.push({
    x: ox,
    y: oy,
    r: 14,
    vx: dx * speed,
    vy: dy * speed,
  });
}

function updateGolemsBullets(dt) {
  const hitbox = getPlayerHitbox();

  for (let i = golemBullets.length - 1; i >= 0; i--) {
    const b = golemBullets[i];

    b.x += b.vx * dt;
    b.y += b.vy * dt;

    // collision
    const closestX = Math.max(hitbox.x, Math.min(b.x, hitbox.x + hitbox.w));
    const closestY = Math.max(hitbox.y, Math.min(b.y, hitbox.y + hitbox.h));

    const dx = b.x - closestX;
    const dy = b.y - closestY;

    if (dx * dx + dy * dy < b.r * b.r) {
      golemBullets.splice(i, 1);
      lifeLost();
      continue;
    }

    // off screen
    if (
      b.x < -50 ||
      b.x > canvas.width + 50 ||
      b.y > canvas.height + 50
    ) {
      golemBullets.splice(i, 1);
    }
  }
}

function drawGolemsBullets() {
  golemBullets.forEach((b) => {
    // bullet tail
    ctx.strokeStyle = "rgba(120,180,255,0.7)";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(b.x - b.vx * 0.02, b.y - b.vy * 0.02);
    ctx.lineTo(b.x, b.y);
    ctx.stroke();

    // bullet body
    ctx.fillStyle = "#ffffff";
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
    ctx.fill();
  });
}


/* ==========================================
   PLUG INTO MAIN LOOP RENDER PHASE
========================================== */

function updateGolems(dt) {
  updateGolemsBullets(dt);
  updateGolems(dt);
}

function drawGolems() {
  drawGolemsBullets();
  drawGolems();
}

/* ==========================================
   PART 3C ‚Äî DAMAGE EFFECTS + VIBRATION + SCALING
========================================== */

let invincible = false;
let invincibleTimer = 0;
let screenShake = 0;

/* Android / iPhone vibration wrapper */
function vibrate(ms) {
  if (navigator.vibrate) {
    navigator.vibrate(ms);
  }
}

/* ==========================================
   LIFE LOST (UPGRADED)
========================================== */
function lifeLost() {
  if (invincible || gameOver) return;

  lives--;

  // vibration feedback
  vibrate(150);

  // flash + shake
  triggerDamageFlash();
  triggerScreenShake();

  // enable invincibility for 1 second
  invincible = true;
  invincibleTimer = 1.0;

  if (lives <= 0) {
    triggerGameOver();
  }
}

/* ==========================================
   INVINCIBILITY TIMER
========================================== */
function updateInvincibility(dt) {
  if (invincible) {
    invincibleTimer -= dt;
    if (invincibleTimer <= 0) {
      invincible = false;
    }
  }
}

/* ==========================================
   DAMAGE FLASH EFFECT
========================================== */
let flashOpacity = 0;

function triggerDamageFlash() {
  flashOpacity = 0.6; // start bright flash
}

function drawDamageFlash() {
  if (flashOpacity > 0) {
    ctx.fillStyle = "rgba(255,0,0," + flashOpacity + ")";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    flashOpacity -= 0.02;
  }
}

/* ==========================================
   SCREEN SHAKE
========================================== */
function triggerScreenShake() {
  screenShake = 12; // intensity
}

function applyScreenShake() {
  if (screenShake > 0) {
    const dx = (Math.random() - 0.5) * screenShake;
    const dy = (Math.random() - 0.5) * screenShake;
    ctx.translate(dx, dy);
    screenShake *= 0.85;
  }
}

/* ==========================================
   WORLD SPAWN SCALING (Difficulty Curve)
========================================== */

function scaledObstacleRate() {
  return Math.max(28 - autoDifficultyLevel * 3, 14);
}

function scaledGiftRate() {
  return Math.max(58 - autoDifficultyLevel * 2, 32);
}

function scaledSnowballRate() {
  return Math.max(115 - autoDifficultyLevel * 5, 60);
}

function scaledGolemRate() {
  return Math.max(190 - autoDifficultyLevel * 6, 90);
}

/* OVERRIDE SPAWN TIMERS USING SCALERS */
function updateObstacles(dt) {
  const fallSpeed = worldSpeed * 1.0;
  obstacleTimer += dt * worldSpeed;

  if (obstacleTimer > scaledObstacleRate()) {
    spawnObstacle();
    obstacleTimer = 0;
  }

  const hitbox = getPlayerHitbox();

  for (let i = obstacles.length - 1; i >= 0; i--) {
    const o = obstacles[i];
    o.y += fallSpeed;

    if (rectsOverlap(hitbox.x, hitbox.y, hitbox.w, hitbox.h, o.x, o.y, o.w, o.h)) {
      obstacles.splice(i, 1);
      lifeLost();
      continue;
    }

    if (o.y > canvas.height + 80) obstacles.splice(i, 1);
  }
}

function updateGifts(dt) {
  const fallSpeed = worldSpeed * 1.0;
  giftTimer += dt * worldSpeed;

  if (giftTimer > scaledGiftRate()) {
    spawnGift();
    giftTimer = 0;
  }

  const hitbox = getPlayerHitbox();

  for (let i = gifts.length - 1; i >= 0; i--) {
    const g = gifts[i];
    g.y += fallSpeed;

    if (rectsOverlap(hitbox.x, hitbox.y, hitbox.w, hitbox.h, g.x, g.y, g.w, g.h)) {
      if (g.type === "points") {
        score += 150;
        vibrate(80);
      } else if (g.type === "life") {
        if (lives < 3) lives++;
        vibrate(80);
      }
      gifts.splice(i, 1);
      continue;
    }

    if (g.y > canvas.height + 80) gifts.splice(i, 1);
  }
}

function updateBigSnowballs(dt) {
  const fall = worldSpeed * 1.1;

  bigSnowballTimer += dt * worldSpeed;

  if (bigSnowballTimer > scaledSnowballRate()) {
    spawnBigSnowball();
    bigSnowballTimer = 0;
  }

  const hitbox = getPlayerHitbox();

  for (let i = bigSnowballs.length - 1; i >= 0; i--) {
    const b = bigSnowballs[i];
    b.y += fall;
    b.x += b.vx;

    const closestX = Math.max(hitbox.x, Math.min(b.x, hitbox.x + hitbox.w));
    const closestY = Math.max(hitbox.y, Math.min(b.y, hitbox.y + hitbox.h));
    const dx = b.x - closestX;
    const dy = b.y - closestY;

    if (dx * dx + dy * dy < b.r * b.r) {
      bigSnowballs.splice(i, 1);
      lifeLost();
      continue;
    }

    if (b.y > canvas.height + b.r) bigSnowballs.splice(i, 1);
  }
}

function updateGolems(dt) {
  const fall = worldSpeed * 0.9;

  golemTimer += dt * worldSpeed;

  if (golemTimer > scaledGolemRate()) {
    spawnGolem();
    golemTimer = 0;
  }

  const hitbox = getPlayerHitbox();

  for (let i = golems.length - 1; i >= 0; i--) {
    const g = golems[i];
    g.y += fall;

    if (rectsOverlap(hitbox.x, hitbox.y, hitbox.w, hitbox.h, g.x, g.y, g.w, g.h)) {
      golems.splice(i, 1);
      lifeLost();
      continue;
    }

    g.shootCooldown -= dt;
    if (g.shootCooldown <= 0) {
      fireGolemSnowball(g);
      g.shootCooldown = 1.2 + Math.random() * 1.2;
    }

    if (g.y > canvas.height + 120) golems.splice(i, 1);
  }
}

/* ==========================================
   UPDATE DAMAGE FX + INVINCIBILITY IN LOOP
========================================== */

const oldGameLoop = gameLoop;
gameLoop = function(timestamp) {
  if (!gameRunning) return;

  const dt = (timestamp - lastTimestamp) / 1000;
  lastTimestamp = timestamp;

  if (!paused) {
    updateAutoDifficulty();
    updateInvincibility(dt);
    updateWorld(dt);
    updatePlayer(dt);
    updateTrail(dt);

    updateObstacles(dt);
    updateGifts(dt);
    updateBigSnowballs(dt);
    updateGolems(dt);
    updateGolemsBullets(dt);
  }

  ctx.save();

  applyScreenShake();
  renderFrame();

  ctx.restore();

  drawDamageFlash();

  requestAnimationFrame(gameLoop);
};


/* ==========================================
   PART 4A ‚Äî LEADERBOARD SYSTEM
========================================== */

/* ==========================================
   UNIQUE DEVICE ID
========================================== */

function getDeviceID() {
  let id = localStorage.getItem("snowglide_device_id");
  if (!id) {
    id = "dev-" + Math.random().toString(36).substr(2, 10);
    localStorage.setItem("snowglide_device_id", id);
  }
  return id;
}

const deviceID = getDeviceID();


/* ==========================================
   BEST SCORE HANDLING
========================================== */

function getBestScore() {
  return Number(localStorage.getItem("snowglide_best_score") || 0);
}

function updateBestScore(score) {
  const best = getBestScore();
  if (score > best) {
    localStorage.setItem("snowglide_best_score", score);
    return true; // means new high score
  }
  return false;
}


/* ==========================================
   API ENDPOINTS
   (Replace with final deployed URLs)
========================================== */

const API_BASE = "https://YOUR_API_URL";    // replace me
const API_SUBMIT = API_BASE + "/leaderboard/submit";
const API_FETCH  = API_BASE + "/leaderboard/list";


/* ==========================================
   SUBMIT SCORE TO SERVER
========================================== */

async function submitScoreToServer(name, score) {
  try {
    const res = await fetch(API_SUBMIT, {
      method: "POST",
      headers: {
        "content-type": "application/json",
        "x-device-id": deviceID
      },
      body: JSON.stringify({ name, score })
    });

    const data = await res.json();
    console.log("Score submitted:", data);
    return data;
  } catch (err) {
    console.error("Error submitting score:", err);
  }
}


/* ==========================================
   AUTO-PUBLISH SCORE ON GAME OVER
========================================== */

async function handleAutoLeaderboardSubmit() {
  const playerName = localStorage.getItem("snowglide_player_name") || null;

  // First time ‚Üí ask name
  if (!playerName) {
    openNameEntry();
    return;
  }

  // update local best
  const isNewBest = updateBestScore(score);

  // send to server only if new best
  if (isNewBest) {
    await submitScoreToServer(playerName, score);
  }
}


/* ==========================================
   OPEN NAME ENTRY MODAL
========================================== */

function openNameEntry() {
  document.getElementById("nameEntryModal").style.display = "flex";
}


/* ==========================================
   SAVE NAME + SUBMIT SCORE
========================================== */

async function submitScore() {
  const input = document.getElementById("playerNameInput");
  const name = input.value.trim();

  if (!name) {
    showToast("Enter a valid name");
    return;
  }

  localStorage.setItem("snowglide_player_name", name);

  updateBestScore(score);

  await submitScoreToServer(name, score);

  document.getElementById("nameEntryModal").style.display = "none";

  showToast("Score Saved!");
}


/* ==========================================
   FETCH LEADERBOARD
========================================== */

async function loadLeaderboard() {
  try {
    const res = await fetch(API_FETCH, {
      headers: {
        "x-device-id": deviceID
      }
    });

    const data = await res.json();

    if (!data || !data.entries) {
      console.error("Invalid leaderboard data");
      return;
    }

    renderLeaderboard(data.entries);
  } catch (err) {
    console.error("Failed to load leaderboard:", err);
  }
}


/* ==========================================
   RENDER LEADERBOARD + HIGHLIGHT PLAYER
========================================== */

function renderLeaderboard(entries) {
  const list = document.getElementById("leaderboardList");
  list.innerHTML = "";

  const playerName = localStorage.getItem("snowglide_player_name");
  const bestScore = getBestScore();

  entries.forEach((row, i) => {
    const div = document.createElement("div");
    div.className = "lbRow";

    // highlight row if it's this player's best score
    if (row.deviceID === deviceID && row.score === bestScore) {
      div.style.background = "rgba(201,226,101,0.25)";
      div.style.border = "1px solid #c9e265";
      div.style.boxShadow = "0 0 8px #c9e265";
    }

    div.innerHTML = `
      <span class="lbRank">#${i + 1}</span>
      <span class="lbName">${row.name}</span>
      <span class="lbScore">${row.score}</span>
    `;

    list.appendChild(div);
  });
}


/* ==========================================
   WHEN USER OPENS LEADERBOARD
========================================== */

function openLeaderboardModal() {
  document.getElementById("leaderboardModal").style.display = "flex";
  loadLeaderboard();
}

function closeLeaderboardModal() {
  document.getElementById("leaderboardModal").style.display = "none";
}

/* ==========================================
   PART 4B ‚Äî MENU + CHARACTER + DIFFICULTY UI
========================================== */

/* ==========================================
   CHARACTER SYSTEM
========================================== */

let selectedCharacter = localStorage.getItem("snowglide_character") || "default";

function selectCharacter(name) {
  selectedCharacter = name;
  localStorage.setItem("snowglide_character", selectedCharacter);

  // highlight UI
  document.querySelectorAll(".characterCard").forEach((c) => {
    c.classList.remove("selected");
    if (c.dataset.char === name) {
      c.classList.add("selected");
    }
  });

  showToast("Character Selected: " + name);
}

function loadSavedCharacterSelection() {
  document.querySelectorAll(".characterCard").forEach((c) => {
    c.classList.remove("selected");
    if (c.dataset.char === selectedCharacter) {
      c.classList.add("selected");
    }
  });
}

/* ==========================================
   DRAW PLAYER USING SELECTED CHARACTER
========================================== */
function drawPlayer() {
  // **TEMP PLACEHOLDER** ‚Äî will use sprite sheet later
  // replacing the rectangle with selected skin color
  ctx.fillStyle = "#ff3366";
  if (selectedCharacter === "snowman") ctx.fillStyle = "#ffffff";
  if (selectedCharacter === "santa") ctx.fillStyle = "#d62828";
  if (selectedCharacter === "elf") ctx.fillStyle = "#1ebd46";
  if (selectedCharacter === "penguin") ctx.fillStyle = "#000000";
  if (selectedCharacter === "polar") ctx.fillStyle = "#b3e2ff";
  if (selectedCharacter === "mrs") ctx.fillStyle = "#ff6fae";

  ctx.fillRect(player.x, player.y, player.width, player.height);

  // Later: replace with sprite images
}


/* ==========================================
   START MENU HANDLERS
========================================== */

function openCharacterScreen() {
  document.getElementById("startScreen").style.display = "none";
  document.getElementById("characterScreen").style.display = "flex";
  loadSavedCharacterSelection();
}

function closeCharacterScreen() {
  document.getElementById("characterScreen").style.display = "none";
  document.getElementById("startScreen").style.display = "flex";
}

function openDifficultyModal() {
  document.getElementById("difficultyModal").style.display = "flex";
}

function closeDifficultyModal() {
  document.getElementById("difficultyModal").style.display = "none";
}

function openHowToPlay() {
  document.getElementById("howToPlayModal").style.display = "flex";
}

function closeHowToPlay() {
  document.getElementById("howToPlayModal").style.display = "none";
}


/* ==========================================
   DIFFICULTY SELECTOR BUTTONS
========================================== */

function chooseDifficulty(mode) {
  difficultyMode = mode;

  // save choice
  localStorage.setItem("snowglide_difficulty", mode);

  showToast("Difficulty set to: " + mode.toUpperCase());

  closeDifficultyModal();
}

function loadSavedDifficulty() {
  const saved = localStorage.getItem("snowglide_difficulty");
  if (saved) {
    difficultyMode = saved;
  }
}


/* ==========================================
   START GAME ‚Üí from menu
========================================== */

function startFromMenu() {
  document.getElementById("startScreen").style.display = "none";
  startGame();
}


/* ==========================================
   BACK BUTTONS
========================================== */

document.querySelectorAll(".backBtn").forEach((btn) => {
  btn.addEventListener("click", () => {
    closeCharacterScreen();
    closeLeaderboardModal();
    closeDifficultyModal();
    closeHowToPlay();

    document.getElementById("startScreen").style.display = "flex";
  });
});


/* ==========================================
   INIT ON LOAD
========================================== */

window.onload = () => {
  loadSavedCharacterSelection();
  loadSavedDifficulty();
};

/* ==========================================
   PART 4C ‚Äî BUTTON CONNECTIONS
========================================== */

// OPEN LEADERBOARD BUTTON
document.getElementById("leaderboardBtn")?.addEventListener("click", () => {
  openLeaderboardModal();
});

// CLOSE LEADERBOARD (already handled by .backBtn)
document.querySelector("#leaderboardModal .backBtn")?.addEventListener("click", () => {
  closeLeaderboardModal();
  document.getElementById("startScreen").style.display = "flex";
});

// CHARACTER SELECT BUTTONS
document.querySelectorAll(".characterCard").forEach((card) => {
  card.addEventListener("click", () => {
    selectCharacter(card.dataset.char);
  });
});

// MENU PLAY BUTTON
document.getElementById("playBtn")?.addEventListener("click", () => {
  startFromMenu();
});

// MENU DIFFICULTY BUTTON
document.getElementById("difficultyBtn")?.addEventListener("click", () => {
  openDifficultyModal();
});

// MENU CHARACTER BUTTON
document.getElementById("characterBtn")?.addEventListener("click", () => {
  openCharacterScreen();
});

// HOW TO PLAY BUTTON
document.getElementById("howBtn")?.addEventListener("click", () => {
  openHowToPlay();
});


</script>

</body>
</html>
